<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhaiworld.github.io/</id>
    <title>zhaiworld</title>
    <updated>2020-07-08T02:48:01.205Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhaiworld.github.io/"/>
    <link rel="self" href="https://zhaiworld.github.io/atom.xml"/>
    <subtitle>有策</subtitle>
    <logo>https://zhaiworld.github.io/images/avatar.png</logo>
    <icon>https://zhaiworld.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zhaiworld</rights>
    <entry>
        <title type="html"><![CDATA[解决Refused to display 'http://*./*' in a frame问题]]></title>
        <id>https://zhaiworld.github.io/post/jie-jue-refused-to-display-http-in-a-frame-wen-ti/</id>
        <link href="https://zhaiworld.github.io/post/jie-jue-refused-to-display-http-in-a-frame-wen-ti/">
        </link>
        <updated>2020-07-08T02:22:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述">问题描述：</h3>
<p>质量管理平台中需要集成另一个系统的报告页面（html，来自Django)，平台集成的方式是通过iframe显示嵌入的页面。但是在加载页面时报错：</p>
<blockquote>
<p>Refused to display 'http://xxxx' in a frame because it set 'X-Frame-Options' to 'sameorigin'.</p>
</blockquote>
<h3 id="解决办法">解决办法：</h3>
<p>在Django项目的setting.py中增加如下配置：</p>
<blockquote>
<p>X_FRAME_OPTIONS = 'ALLOWALL'<br>
在网上找到了类似的解决方法：<br>
X_FRAME_OPTIONS = 'ALLOWALL url'   # url为指定地址</p>
</blockquote>
<p>但是经过实验发现，'ALLOWALL'、'ALLOW'、'ALLOWALL 非质量平台的IP地址'，这三种情况都是访问正常的。不理解为什么第三种情况也是OK的，有懂的朋友欢迎留言指点！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GIT操作]]></title>
        <id>https://zhaiworld.github.io/post/git-cao-zuo/</id>
        <link href="https://zhaiworld.github.io/post/git-cao-zuo/">
        </link>
        <updated>2020-07-07T02:12:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分支">分支</h3>
<p><strong>显示所有分支</strong><br>
git branch -a<br>
<strong>切换当前分支</strong><br>
git checkout <branch><br>
<strong>创建新分支，基于当前分支</strong><br>
git branch &lt;new_branch&gt;<br>
<strong>删除本地分支</strong><br>
git branch -d <branch></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[APP Push及测试点]]></title>
        <id>https://zhaiworld.github.io/post/app-push-ji-ce-shi-dian/</id>
        <link href="https://zhaiworld.github.io/post/app-push-ji-ce-shi-dian/">
        </link>
        <updated>2020-07-06T12:37:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>消息推送是APP触达用户的优质渠道之一，在App开发中应用的场景是十分常见。</p>
<h3 id="ios-push-原理">iOS Push 原理</h3>
<p>iOS应用的推送大部分情况下都要依赖苹果生态提供的APNs（Apple Push Notification Service）服务。<a href="https://www.jianshu.com/p/5d83250fb5a1">扩展阅读：</a></p>
<h4 id="在线push">在线Push</h4>
<p>当用户在线（APP在前台）时，收到的状态栏的消息提醒，称为在线push。这个功能与苹果系统无关，是我们自己的APP开发的一种功能，该push与设置中是否打开“通知”无关。<br>
判断app是否在线，此处可以根据APP自身的后台策略如上一次与后台交互的时间等方法来判断APP是否在线或者离线。认为在线，会发送在线push，否则，发送离线push。<br>
在线push有以下几个特点：</p>
<ul>
<li>不需要经过苹果APNs。</li>
<li>需要自己实现长链接。</li>
<li>代码在app内部实现。</li>
</ul>
<h4 id="离线push">离线Push</h4>
<p>离线push：当APP在离线（kill掉进程、切到后台、锁屏）时，收到的消息提醒，称为离线push。离线push是需要经过苹果的APNs服务器才可以推送到某台设备的某个APP上的，这是和本地push的本质区别。push与设置中是否打开“通知”有关。<br>
收到推送后（有文字有声音），点开通知，进入APP后，才执行。<br>
主要流程为：</p>
<ol>
<li>服务器端将消息先发送到苹果的APNs</li>
<li>由苹果的APNs将消息推送到客户的设备端</li>
<li>由iOS系统将接收到的消息传递给相应的App。<br>
简而言之离线push是苹果系统的行为，与app状态无关，能够直接推送到指定手机的指定app。<br>
<strong>离线push名词解释—APNs</strong><br>
APNs：Apple Push Notification service(苹果推送通知服务)。<br>
APNs主要用于以下场景：当用户主动杀掉 APP，或者 APP 进入后台超过约定时长时，APP会被kill，这样保障了前台 APP 的流畅性，也延长了手机的使用时长，获得了较好的用户体验，但是这也意味着，服务器无法主动和用户交互（如推送实时消息等），所以苹果推出了 APNs，允许设备和服务器分别与苹果的推送通知服务器保持长连接状态。<br>
关于APNs的更新有以下几点：<br>
● iOS 8以后，APNs推送的字节是2k，iOS8以前是256字节<br>
● iOS 9以后APNs支持HTTP/2协议栈，优化长连接，具有标准的HTTP返回和管道复用技术<br>
● iOS 10以后，推送的字节是4k，APNs可根据推送消息的唯一标示符查询某条消息是否被用户阅读，可更新某一推送消息，而不用发重读的多条消息</li>
</ol>
<h4 id="本地push">本地Push</h4>
<p>本地推送和远程推送的功能是一样的，都是要提醒用户去做某些事情。但是和远程推送不同的就是本地推送是不需要设备联网的，而远程推送是必需要设备联网的，因为只有联网状态下，才能和苹果的APNs服务器建立长连接，从而推送消息。本地推送是由App自己设定的，并且发送给安装此App的这台设备，属于一对一的对应关系。比较典型的应用是闹钟类似的场景。该push与设置中是否打开“通知”有关。</p>
<h3 id="安卓push">安卓Push</h3>
<h4 id="推送实现原理">推送实现原理</h4>
<p>接下来单看看目前各大平台对于推送的架构设计。<br>
推送包括 通道，客户端，和服务端 三层架构。<br>
推送设计实现<br>
<strong>主要是两种实现方式：</strong></p>
<ol>
<li>pull （客户端主动获取）<br>
客户端固定时间主动向服务端获取信息，若有更新信息，则发送至客户端<br>
心跳：轮询时间短:耗电,耗流量。时间长，不能保证消息及时。<br>
轮询：<br>
Timer：WakeLock 让CPU 保持唤醒，耗电量很大<br>
AlarmManager：管理独立的硬件时钟RTC，可以在CPU休眠的时候正常运行。在预设的时间到达之后，唤醒CPU。这样CPU可以正常休眠，只需要任务到达之后醒来一段很短的时间。极光推送就是基于此实现的。</li>
<li>push<br>
客户端被动接受）当服务端有更新时，主动发送到客户端：<br>
主要方式有：SMS、websocket, 长连接<br>
长连接又包括三种方式：<br>
GCM：google的Gcm，容易被国内厂商阉割，而且NAT（Network AddressTranslation）容易超时，长连接无法保持，造成消息推送延迟。<br>
第三方推送：友盟、极光，腾讯信鸽<br>
自定义长连接：长连接、心跳和推送及时率。<br>
保持长连接，是消息及时的重要保证。发送心跳包，如果前台检测发送失败，则重新初始化一个socket。</li>
</ol>
<h4 id="第三方推送平台">第三方推送平台</h4>
<p>这是目前使用广泛也是比较推荐的安卓推送方案，现今主流的推送平台分为</p>
<ol>
<li>手机厂商类：小米推送、华为推送。</li>
<li>第三方平台类：友盟推送、极光推送、云巴（基于MQTT）</li>
<li>BAT大厂的平台推送：阿里云移动推送、腾讯信鸽推送、百度云推送</li>
</ol>
<h4 id="安卓与ios推送的区别">安卓与iOS推送的区别</h4>
<ul>
<li>实现方式：安卓由每个应用各自维护自身的长链接，属于应用级别；ios由ios系统自身维护1个长链接，属于系统级别</li>
<li>原理：安卓推送原理主要是push，pull的方式按需实现;ios客户端将消息推送至苹果服务器，苹果服务器通过该系统级别的长连接，推送到客户端</li>
<li>其他区别：安卓推送到达率低，属于应用级别么容易被系统杀死，维护多个长连接，耗电量高；ios 推送到达率高，长连接不容易被系统杀死，耗电量低</li>
</ul>
<h3 id="测试要点">测试要点</h3>
<ul>
<li>push到达：这是最今本功能，即push能否及时到达，并展示正常</li>
<li>点击push响应：点击push后，能够跳转到对应内容</li>
<li>不同界面打开push：点击push可以直接打开app的某个界面，在不同的界面打开push后，再点击返回可能出现问题，要关注能否正常退出push打开的界面</li>
<li>系统兼容：ios的push机制一直在更新，特别是iOS10后有较大更新，要注意是否能够兼容不同的iOS系统</li>
<li>展开界面功能是否正常：比如push展开后，可能有”收藏“，“评论”等功能，点击这些功能进行使用是否能够正常响应</li>
<li>重装app：卸载重装之后，是否会收到多条push等异常</li>
<li>切换账号：用户切换账号之后是否会出现旧的账号的push等异常</li>
<li>角标计数：理论上没收到一条新的push，角标都+1，看角标计数是否正常</li>
<li>角标消失：打开push或者app之后，角标能否正常消失</li>
<li>多端同时在线：支持多端登录的app，能否在每一端都收到push</li>
<li>游客与登录状态：有些app支持游客态登录，能否正常收到push</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Liunx]]></title>
        <id>https://zhaiworld.github.io/post/linux/</id>
        <link href="https://zhaiworld.github.io/post/linux/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介讲解编辑神器vi">简介：讲解编辑神器vi</h3>
<h4 id="vi的基本概念三种模式">vi的基本概念:（三种模式）</h4>
<ul>
<li>命令模式</li>
<li>插入模式</li>
<li>底行模式</li>
</ul>
<blockquote>
<p>进入插入模式：按住键盘的 i 或者 o 或者 a<br>
进入命令模式：按住键盘的左上角esc键<br>
进入底行模式：前提是得在命令模式，输入 ： 进入</p>
</blockquote>
<h5 id="在命令模式中的操作">在命令模式中的操作</h5>
<p>$ ——&gt;移动到这一行的行尾<br>
gg ——&gt;移动到文档第一行行首<br>
G ——&gt;移动到文档最后一行行首<br>
x ——&gt;删除内容，删除一个字符<br>
dd ——&gt;删除游标所在的那一整行<br>
u ——&gt;复原原来的操作<br>
v ——&gt;选中范围按y即复制<br>
p ——&gt;粘贴</p>
<h5 id="在底行模式中的操作">在底行模式中的操作</h5>
<p>n ——&gt;n为数字。光标移动到第n 行<br>
/ ——&gt;寻找内容<br>
%s/word1/word2/g ——&gt;从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2<br>
n1,n2s/word1/word2/g ——&gt;n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代 为 word2<br>
set nu ——&gt;显示行号<br>
set nonu ——&gt;取消行号<br>
q! ——&gt;强制离开不保存<br>
wq ——&gt;离开并保存<br>
wq! ——&gt;强制离开并保存<br>
!ls ——&gt;暂时离开</p>
]]></content>
    </entry>
</feed>